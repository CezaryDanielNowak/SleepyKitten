'use strict';

const React = require('react');
const RouterContext = require('react-router').RouterContext;
const browserHistory = require('react-router').browserHistory;
const match = require('react-router').match;
const ReactDOMServer = require('react-dom/server');
const config = require('../config.js');
const safeRequire = require('protected-require');
const gutil = require('gulp-util');
global.superagent = require('superagent');

const DEFAULT_BUNDLE = 'app.js';

/**
 * getBundle requires file from destination dir (dist/). It's used to acquire
 * bundle generated by webpack. It's needed for server-side rendering, as Node
 * doesn't have full ES6 support.
 *
 * @param  {string} fileName  file name to require
 * @return {mixed}            content of required file.
 */
function getBundle(fileName) {
  try {
    const componentsPath = require.resolve(`${config.DESTINATION_DIR}/${fileName}`);
    if (config.ENV === 'local') {
      setTimeout(() => {
        // clear cache entry, so file is reloaded.
        delete require.cache[componentsPath];
      });
    }

    return safeRequire(componentsPath, true);
  } catch (err) {
    gutil.log(`WARNING: ${fileName} bundle invalid`);
  }
}

/**
 * generateHtmlMarkup renders Html.js and puts providen content inside template.
 * @param  {[type]} codeInside code inside template.
 * @return {string}            Output markup
 */
function generateHtmlMarkup(codeInside, bundleName) {
  const bundle = getBundle(bundleName || DEFAULT_BUNDLE);
  const HtmlLayout = bundle['./layout/Html'];

  const markup = ReactDOMServer.renderToStaticMarkup(
    React.createElement(
      HtmlLayout,
      null,
      codeInside || ''
    )
  );
  // NASTY, UGLY HACK, react is converting
  // <meta content="default-src *; style-src 'self' 'unsafe-inline';" />
  // into
  // <meta content="default-src *; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;;" />
  // and I don't see a solution for it.
  const markupParts = markup.split('</head>');
  markupParts[0] = markupParts[0].replace(/\&#x27;/g, '\'');
  return `<!DOCTYPE html>${markupParts.join('</head>')}`;
}

/**
 * generate markup based on provided location and routing.
 * @param  {string} location
 * @return {Promise}
 */
function generateMarkup(location, bundleName) {
  const bundle = getBundle(bundleName || DEFAULT_BUNDLE);
  const routes = bundle['./routes'];

  return new Promise((resolve) => {
    match({
      routes,
      location,
      history: browserHistory
    }, (err, redirectLocation, renderProps) => {
      if (err) {
        return resolve({
          error: err
        });
      } else if (redirectLocation) {
        return resolve({
          redirect: redirectLocation
        });
      }
      try {
        if (renderProps) {
          resolve({
            data: generateHtmlMarkup(
              ReactDOMServer.renderToString(
                React.createElement(RouterContext, renderProps)
              ),
              bundleName || DEFAULT_BUNDLE
            )
          });
        } else {
          resolve({
            error: new Error('404 Error.')
          });
        }
      } catch (e) {
        gutil.log(e);
        return resolve({
          error: e
        });
      }
    });
  });
}

function getAllPages(bundleName) {
  const bundle = getBundle(bundleName || DEFAULT_BUNDLE);
  const routes = bundle['./routes'];
  const result = {};

  return new Promise((resolve) => {
    const promises = [];
    const allPagesGenerator = function (children) {
      if (children instanceof Array) {
        return children.forEach(allPagesGenerator);
      }

      if (!children.props) return console.error('There is an error in your routes.js. Skipping for now.');

      let location = children.props.path;
      if (children.type.displayName === 'IndexRoute') {
        location = '/';
      }

      if (children.props.children) {
        if (children.props.children instanceof Array) {
          children.props.children.forEach(allPagesGenerator);
        } else {
          // one child
          allPagesGenerator(children.props.children);
        }
      }

      if (location && location !== '*' && !location.includes(':')) {
        promises.push(
          generateMarkup(location, bundleName || DEFAULT_BUNDLE)
            .then((resultObj) => {
              gutil.log('GENERATE: ', location);
              result[location] = resultObj.data;
            })
            .catch((err) => {
              console.error(location, bundleName || DEFAULT_BUNDLE, err);
            })
        );
      }
    };
    routes.props.children.forEach(allPagesGenerator);

    Promise.all(promises).then(() => resolve(result));
  });
}

module.exports = {
  getBundle,
  generateHtmlMarkup,
  generateMarkup,
  getAllPages
};
